#' causalsim: A package to explore linear causal DAGs
#' 
#' The causalsim package uses a matrix containing the 
#' coefficients and standard deviations of the unique
#' independent components of a linear causal
#' DAG to generate the marginal covariance matrix and to 
#' calculate the value of coefficients of
#' linear models applied to a population generated by
#' the causal DAG.  
#' 
#' See \code{\link{coefx}} for an extended example.
#' 
#' @docType package
#' @name causalsim
NULL
#' Covariance matrix for a linear DAG
#' 
#' Computes the overall covariance matrix generated
#' by the coefficients of a linear DAG. 
#' See \code{\link{coefx}} for an extended example.
#' 
#' @param mat a matrix defining a linear DAG. See
#'        \code{\link{coefx}}.
#' @return the variance matrix implied by the 
#'         linear DAG.
#' @export
covld <- function(mat) {
	# mat is a lower triangular matrix representing 
	# causal coefficients along the arrows of a 
	# linear causal DAG with normal stochastic components.
	#
	# The diagonal elements show the standard deviation
	# of the unique normal errors added in generating
	# each variable.
	
	# check if strict lower diag
	# if(sum(abs(mat[col(mat)>row(mat)])) > 0) stop('matrix must be lower diagonal')
	mat <- to_dag(mat)
	# initialize returned v matrix
	v <- diag(nrow(mat))
	dimnames(v) <- dimnames(mat)
	v[1,1] <- mat[1,1]^2
	for(i in 2:ncol(v)) {
		A <- rbind(
			cbind(diag(i-1), 0),
			mat[i, seq_len(i)])
		v[seq_len(i),seq_len(i)] <- A %*% v[seq_len(i),seq_len(i)] %*% t(A)
	}
	v
}
#' Transform a matrix of causal coefficients to a DAG
#' 
#' A square matrix containing causal coefficients with 
#' standard deviation of unique components on the
#' diagonal is transformed into a lower-triangular
#' matrix by permutations of its rows and columns,
#' if possible. Otherwise an error is produced.
#' 
#' See \code{\link{coefx}} for an extended example.
#'
#' @param mat a square matrix with variable names
#'        for rows and columns. Off-diagonal entries
#'        are causal coefficients for the row
#'        variable depending on the column variables.
#'        The diagonal elements are standard deviations
#'        of the the independent component producing
#'        variability in the row variable. 
#' @return If the input matrix represents a DAG,
#'        the input matrix with permuted rows and
#'        columns as a lower diagonal matrix. Thus
#'        data from the DAG can be generated by
#'        simulating variables in the same order
#'        as the row order. If the input matrix
#'        cannot define a DAG (i.e. is not
#'        acyclic) the function return FALSE
#'        with an error message.
#' @export
to_dag <- function(mat){
  # check that mat has unique column and row names
  find_leaves <- function(m) {
    sumabs <- function(x) sum(abs(x))
    diag(m) <- 0 # in case they're used for epsilons
    which(apply(m,2,sumabs)==0)
  }
  if(nrow(mat) != ncol(mat)) stop('matrix must be square')
  if(any(sort(colnames(mat)) != sort(rownames(mat)))) stop('colnames not same as rownames')
  if(length(unique(colnames(mat))) != length(colnames(mat))) stop('names not unique')
  mat <- mat[colnames(mat), colnames(mat)]
  if(sum(abs(mat[row(mat) < col(mat)])) == 0) {
    # matrix already lower diagonal  
    class(mat) <- unique(c('dag', class(mat)))
    return(mat)
  }
  ret <- mat
  dag_perm <- rep('', nrow(mat))
  for(i in 1:nrow(ret)) {
    # disp(i)
    # disp(mat)
    ll <- find_leaves(mat)
    if(length(ll) == 0) return(FALSE)
    dag_perm[i] <- names(ll[1])
    # disp(dag_perm)
    if(i < nrow(ret)) mat <- mat[-ll[1],-ll[1], drop = FALSE]
  }
  ret <- ret[rev(dag_perm),rev(dag_perm)]
  class(ret) <- unique(c('dag', class(ret)))
  ret
}
#' @export
permute_to_dag <- to_dag
#' Multiple regression coefficient from a linear DAG
#' 
#' Given a linear DAG, find the population regression 
#' coefficents using data with the marginal covariance
#' structure implied by the linear DAG.
#' 
#' @param fmla a linear model formula. The variables
#'        in the formula must be column names of 
#'        \code{dag}.
#' @param dag a square matrix defining a linear DAG. The
#'        column names and row names of A must be 
#'        identical.  The non-diagonal entries of 
#'        \code{dag} contain the causal of coefficients
#'        of arrows pointing from the column variable
#'        to the row variable.  The diagonal entries
#'        are standard deviations of the normally
#'        distributed independent component generating
#'        the row variable. A matrix
#'        defines a linear dag if the same permutation
#'        of its rows and columns can transform it into
#'        a lower diagonal matrix.
#' @param var variance matrix of variables if entered directly
#'        without a dag.
#' @return a list with class 'coefx' containing 
#'        the population coefficient for the first
#'        predictor variable in \code{fmla}, the residual 
#'        standard error of the regression, the conditional
#'        standard deviation of the residual of the first
#'        predictor and the ratio of the last two quantities
#'        which constitutes the 'standard error factor' which,
#'        if multiplied by 1/sqrt(n) is an estimate of the
#'        standard error of the estimate of the regression
#'        coefficient for the first predictor variable.
#' @examples
#' nams <- c('zc','zl','zr','c','x','y','m','i')
#' mat <- matrix(0, length(nams), length(nams))
#' rownames(mat) <- nams
#' colnames(mat) <- nams
#' 
#' # confounding back-door path
#' mat['zl','zc'] <- 2 
#' mat['zr','zc'] <- 2
#' mat['x','zl'] <- 1
#' mat['y','zr'] <- 2
#' 
#' # direct effect
#' mat['y','x'] <- 3
#' 
#' # indirect effect
#' mat['m','x'] <- 1
#' mat['y','m'] <- 1
#' 
#' # Instrumental variable 
#' mat['x','i'] <- 2
#' 
#' # 'Covariate'
#' mat['y','c'] <- 1
#' 
#' # independent error
#' diag(mat) <- 2
#' 
#' mat # not in lower diagonal form   
#' dag <- to_dag(mat) # can be permuted to lower-diagonal form
#' dag
#' 
#' coefx(y ~ x, dag)  # with confounding
#' coefx(y ~ x + zc, dag)  # blocking back-door path
#' coefx(y ~ x + zr, dag) # blocking with lower SE
#' coefx(y ~ x + zl, dag) # blocking with worse SE
#' coefx(y ~ x + zr + c, dag)  # adding a 'covariate'
#' coefx(y ~ x + zr + m, dag)  # including a mediator
#' coefx(y ~ x + zl + i, dag)  # including an instrument
#' coefx(y ~ x + zl + i + c, dag) # I and C
#' 
#' # plotting added-variable plot ellipse 
#' lines(
#'     coefx(y ~ x + zr, mat),  
#'     lwd = 2, xv= 5,xlim = c(-5,10), ylim = c(-25, 50))
#' lines(
#'     coefx(y ~ x + zl, mat), new = FALSE,
#'     col = 'red', xv = 5, lwd = 2)
#' lines(
#'     coefx(y ~ x + i, mat), new = FALSE,
#'     col = 'dark green', xv = 5)
#' 
#' # putting results in a data frame
#' # for easier comparison of SEs
#' 
#' fmlas <- list(
#'   y ~ x, 
#'   y ~ x + zc, 
#'   y ~ x + zr, 
#'   y ~ x + zl,
#'   y ~ x + zr + c, 
#'   y ~ x + zr + m, 
#'   y ~ x + zl + i,
#'   y ~ x + zl + i + c
#' )
#' res <- lapply(fmlas, coefx, dag)
#' res <- lapply(res, function(ll) {
#'     ll$fmla <- paste(as.character(ll$fmla)[c(2,1,3)], collapse = ' ')
#'     ll$beta <- ll$beta[1]
#'     ll
#' })
#' 
#' df <- do.call(rbind.data.frame, res)
#' df 
#' 
#' # simulation
#' 
#' head(sim(dag, 100))
#' var(sim(dag, 10000)) - covld(dag)
#' 
#' # plotting
#'
#' plot(dag)
#' 
#' @export
coefx <- function(fmla, dag, var = covld(to_dag(dag)), iv = NULL){
	ynam <- as.character(fmla)[2]
	xnam <- labels(terms(fmla))
	if(any(grepl('\\|', xnam)) | !is.null(iv)) {
	  return(coefxiv(fmla, var = var, iv = iv))
	}
	var <- var[c(ynam,xnam),c(ynam,xnam)]
	beta <- solve(var[-1,-1], var[1,-1])
	sd_e <- sqrt(var[1,1] - sum(var[1,-1]*beta))
	sd_x_avp <- sqrt(1/solve(var[-1,-1])[1,1])
	label <- paste(as.character(fmla)[c(2,1,3)], collapse = ' ')
	ret <- list(beta=beta, sd_e =sd_e, sd_x_avp = sd_x_avp,
		 sd_betax_factor = sd_e/sd_x_avp, fmla = fmla, label = label)
	class(ret) <- 'coefx'
	ret
}
#' Regression coefficient from a linear DAG possibly using an IV
#' 
#' Given a linear DAG, find the population regression 
#' coefficient for X using IV estimation
#' using data with the marginal covariance
#' structure implied by the linear DAG.
#' 
#' @param fmla a linear model formula. The variables
#'        in the formula must be column names of 
#'        \code{dag}. For IV estimation, the right
#'        hand side should have two variables, the
#'        first one will be treated as the 'X'
#'        variable and the second, as the IV.
#' @param dag a square matrix defining a linear DAG. The
#'        column names and row names of A must be 
#'        identical.  The non-diagonal entries of 
#'        \code{dag} contain the causal of coefficients
#'        of arrows pointing from the column variable
#'        to the row variable.  The diagonal entries
#'        are standard deviations of the normally
#'        distributed independent component generating
#'        the row variable. A matrix
#'        defines a linear dag if the same permutation
#'        of its rows and columns can transform it into
#'        a lower diagonal matrix.
#' @param iv a one-sided formula with a single variable (at present)
#'        specifying a variable to be used as an instrumental variable
#' @param var the variance matrix of the variables, as an alternative
#'        input to 'dag'. If 'var' is provided, then dag does not
#'        need to be provided.
#' @return a list with class 'coefx' containing 
#'        the population coefficient for the first
#'        predictor variable in \code{fmla}, the residual 
#'        standard error of the regression, the conditional
#'        standard deviation of the residual of the first
#'        predictor and the ratio of the last two quantities
#'        which constitutes the 'standard error factor' which,
#'        if multiplied by 1/sqrt(n) is an estimate of the
#'        standard error of the estimate of the regression
#'        coefficient for the first predictor variable.
#' @export
coefxiv <- function(fmla, dag, iv = NULL, var = covld(to_dag(dag))){
  sepiv <- function(fmla) {
    # separate model formula and iv from formula
    cfmla <- as.character(fmla)
    fmla <- as.formula(paste(cfmla[2], ' ~ ', sub('\\|.*$','',cfmla[3])))
    iv <- if(grepl('\\|', cfmla[3])) as.formula(paste( ' ~ ', sub('^.*\\|','',cfmla[3]))) else NULL
    list(fmla, iv)
  }
  v <- var
  if(grepl('\\|',as.character(fmla)[3] )){
    fmiv <- sepiv(fmla)
    fmla <- fmiv[[1]]
    iv <- fmiv[[2]]
  }
  ynam <- as.character(fmla)[2]
  xnam <- labels(terms(fmla))
  if(!is.null(iv)) {
    if(length(xnam) > 1) warning('coefxiv currently supports only one X variable for IV analyses')
    xnam <- xnam[1]
  }
  if(!is.null(iv)) ivnam <- as.character(iv)[2]
  
  if(!is.null(iv)) v <- v[c(ynam,xnam,ivnam),c(ynam,xnam,ivnam)]
  else  v <- v[c(ynam,xnam),c(ynam,xnam)]
  if(is.null(iv)) beta <- solve(v[-1,-1], v[1,-1])
  else beta <- v[1,3]/v[2,3]
  if(is.null(iv)) sd_e <- sqrt(v[1,1] - sum(v[1,-1]*beta))
  else sd_e <- sqrt(
    v[1,1] + beta^2 * v[2,2] - 2 * beta * v[1,2]
  )
  if(is.null(iv)) sd_x_avp <- sqrt(1/solve(v[-1,-1])[1,1])
  else sd_x_avp <- v[2,3]/sqrt(v[3,3])   # Fox, p. 233, eqn 9.29
  
  if(is.null(iv)) label <- 
    paste(as.character(fmla)[c(2,1,3)], collapse = ' ')
  else label <- paste0(ynam, ' ~ ', xnam, ' (IV = ', ivnam,')')
  ret <- list(beta=beta, sd_e =sd_e, sd_x_avp = sd_x_avp,
              sd_betax_factor = sd_e/sd_x_avp, fmla = fmla, 
              iv = if(is.null(iv)) '' else iv,
              label = label,
              dag = if(!missing(dag)) dag else '',
              var = v)
  class(ret) <- c('coefx')
  ret
}
#' @export
as.data.frame.coefx <- function(x, ...) {
  with(x, data.frame(beta_x = beta[1], sd_e = sd_e, sd_x_avp = sd_x_avp,
                     sd_factor = sd_betax_factor, label = label))
}
#' 
#' Plotting the added-variable plot for linear DAG
#' 
#' See \code{\link{coefx}} for an extended example.
#' 
#' @param cx an object of class 'coefx' produced by
#'        \code{\link{coefx}}.
#' @param new if FALSE add to previous plot. Default: TRUE.
#' @param xvertical position of vertical line to help visualize
#'        standard error factor. Default: 1.
#' @param col color of ellipse and lines. Default: 'black'.
#' @param lwd line width.
#' @param \dots other arguments passed to \code{\link{plot}}.
#' @export
lines.coefx <- function(cx, new = TRUE, xvertical = 1,  col = 'black', lwd = 2, ...) {
	fmla <- as.character(cx$fmla)
	xlab <- sub(' .*$','',fmla[3])
	ylab <- fmla[2]
	mlab <- paste(fmla[1], fmla[3])
	Tr <- with(cx, matrix(c(0, sd_e, sd_x_avp, sd_x_avp * beta[1]), nrow = 2))
	if(new) plot(ell(shape = Tr %*% t(Tr)), col = col, type = 'l', xlab = xlab, ylab = ylab, lwd = lwd, ...)
	else lines(ell(shape = Tr %*% t(Tr)), col = col, lwd = lwd) 
	abline(a=0,b=cx$beta[1], col = col, lwd = lwd)
	with(cx, abline(a=0,b=beta[1]- sd_e/sd_x_avp, col = col, lwd = lwd))
	with(cx, abline(a=0,b=beta[1]+ sd_e/sd_x_avp, col = col, lwd = lwd))
	abline(v = xvertical, lwd = lwd)
	with(cx, text(xvertical, xvertical *(beta[1]- sd_e/sd_x_avp), paste(' ',mlab) , adj = 0, cex = 1, col = col, ...))
}
#' @export
lines_ <-function(x, col = 'black', xvertical = 1, new = F, lwd = 2, ...) {
	lines(x, col = col, xvertical = xvertical , new = new, lwd = lwd, ... )
}
#' @export
ell <-
function (center = rep(0, 2), shape = diag(2), radius = 1, n = 100) 
{
    fac <- function(x) {
        xx <- svd(x, nu = 0)
        t(xx$v) * sqrt(pmax(xx$d, 0))
    }
    angles = (0:n) * 2 * pi/n
    if (length(radius) > 1) {
        ret <- lapply(radius, function(r) rbind(r * cbind(cos(angles), 
            sin(angles)), NA))
        circle <- do.call(rbind, ret)
    }
    else circle = radius * cbind(cos(angles), sin(angles))
    ret <- t(c(center) + t(circle %*% fac(shape)))
    attr(ret, "parms") <- list(center = rbind(center), 
        shape = shape, radius = radius)
    class(ret) <- "ell"
    ret
}
#' Simulate a data frame from a DAG
#' 
#' Simulates a data frame from the multivariate normal
#' distribution generated by a DAG
#' 
#' @param dag a lower triangular matrix representing a
#'        DAG or a matrix that can be permutted into
#'        such a matrix.
#' @param n the number of observations to generate.
#' @return a data frame with one column for each
#'        variable in the DAG. The variables are
#'        generated from a multivariate normal 
#'        distribution with mean zero
#'        and variance matrix implied by the 
#'        coefficients of the DAG.
#' @export
sim <- function(dag, n) {
    fac <- function(x) {
        xx <- svd(x, nu = 0)
        t(xx$v) * sqrt(pmax(xx$d, 0))
    }
	dag <- to_dag(dag)
	v <- covld(dag)
	E <- matrix(rnorm(n*ncol(dag)), nrow = n, ncol = ncol(dag))
	ret <- as.data.frame(E%*%fac(v))
	names(ret) <- colnames(dag)
	ret
}
#' Plot a causal graph
#' 
#' Uses \code{\link[ggdag]{ggdag}} to plot the graph of a DAG.
#' 
#' @param dag a lower-triangular matrix representing a DAG. In
#'        constrast with other function, the DAG argument must
#'        have class 'dag' and, so, must have been constructed
#'        with \code{\link{to_dag}}.
#' @param ... passed to \code{\link[ggdag]{ggdag}}.
#' @return plots a causal graph with \code{\link[ggdag]{ggdag}}.
#' @export
plot.dag <- function(dag, ...) {
  makedagitty <- function(mat) {
    string <- ''
    df <- as.data.frame(as.table(dag))
    df <- subset(df, Var1 != Var2)
    df <- subset(df, Freq > 0)
    for(i in seq_len(nrow(df))) {
      string <- paste(string,' ',df[i,'Var1'],' <- ', df[i,'Var2'] )
    }
    string <- paste('dag{', string, '}')
    dagitty::dagitty(string)
  }
  ggdag::ggdag(makedagitty(dag), ...)
}  
