#' causalsim: A package to explore linear causal DAGs
#' 
#' The causalsim package uses a matrix containing the 
#' coefficients and standard deviations of the unique
#' independent components of a linear causal
#' DAG to generate the marginal covariance matrix and to 
#' calculate the value of cofficients of
#' linear models applied to a population generated by
#' the causal DAG.  
#' 
#' See \code{\link{coefx}} for an extended example.
#' 
#' @docType package
#' @name causalsim
NULL
#' Covariance matrix for a linear DAG
#' 
#' Computes the overall covariance matrix generated
#' by the coefficients of a linear DAG. 
#' See \code{\link{coefx}} for an extended example.
#' 
#' @param mat a matrix defining a linear DAG. See
#'        \code{\link{coefx}}.
#' @return the variance matrix implied by the 
#'         linear DAG.
#' @export
covld <- function(mat) {
	# mat is a lower triangular matrix representing 
	# causal coefficients along the arrows of a 
	# linear causal DAG with normal stochastic components.
	#
	# The diagonal elements show the standard deviation
	# of the unique normal errors added in generating
	# each variable.
	
	# check if strict lower diag
	# if(sum(abs(mat[col(mat)>row(mat)])) > 0) stop('matrix must be lower diagonal')
	mat <- to_dag(mat)
	# initialize returned v matrix
	v <- diag(nrow(mat))
	dimnames(v) <- dimnames(mat)
	v[1,1] <- mat[1,1]^2
	for(i in 2:ncol(v)) {
		A <- rbind(
			cbind(diag(i-1), 0),
			mat[i, seq_len(i)])
		v[seq_len(i),seq_len(i)] <- A %*% v[seq_len(i),seq_len(i)] %*% t(A)
	}
	v
}
#' Transform a matrix of causal coefficients to a DAG
#' 
#' A square matrix containing causal coefficients with 
#' standard deviation of unique components on the
#' diagonal is transformend into a lower-triangular
#' matrix by permutations of its rows and columns,
#' if possible. Otherwise an error is produced.
#' 
#' See \code{\link{coefx}} for an extended example.
#'
#' @param mat a square matrix with variable names
#'        for rows and columns. Off-diagonal entries
#'        are causal coefficients for the row
#'        variable depending on the column variables.
#'        The diagonal elememts are standard deviations
#'        of the the independent component producing
#'        variability in the row variable. 
#' @return If the input matrix represents a DAG,
#'        the input matrix with permuted rows and
#'        columns as a lower diagonal matrix. Thus
#'        data from the DAG can be generated by
#'        simulating variables in the same order
#'        as the row order. If the input matrix
#'        cannot define a DAG (i.e. is not
#'        acyclic) the function return FALSE
#'        with an error message.
#' @export
to_dag <- function(mat){
  # check that mat has unique column and row names
  find_leaves <- function(m) {
    sumabs <- function(x) sum(abs(x))
    diag(m) <- 0 # in case they're used for epsilons
    which(apply(m,2,sumabs)==0)
  }
  if(nrow(mat) != ncol(mat)) stop('matrix must be square')
  if(any(sort(colnames(mat)) != sort(rownames(mat)))) stop('colnames not same as rownames')
  if(length(unique(colnames(mat))) != length(colnames(mat))) stop('names not unique')
  mat <- mat[colnames(mat), colnames(mat)]
  ret <- mat
  dag_perm <- rep('', nrow(mat))
  
  for(i in 1:nrow(ret)) {
    # disp(i)
    # disp(mat)
    ll <- find_leaves(mat)
    if(length(ll) == 0) return(FALSE)
    dag_perm[i] <- names(ll[1])
    # disp(dag_perm)
    if(i < nrow(ret)) mat <- mat[-ll[1],-ll[1], drop = FALSE]
  }
  ret[rev(dag_perm),rev(dag_perm)]
}
#' Multiple regression oefficient from a linear DAG
#' 
#' Given a linear DAG, find the population regression 
#' coefficent using data with the marginal covariance
#' structure implied by the linear DAG.
#' 
#' @param fmla a linear model formula. The variables
#'        in the formula must be column names of 
#'        \code{dag}.
#' @param dag a square matrix defining a linear DAG. The
#'        column names and row names of A must be 
#'        identical.  The non-diagonal entries of 
#'        \code{dag} contain the causal of coefficients
#'        of arrows pointing from the column variable
#'        to the row variable.  The diagonal entries
#'        are standard deviations of the normally
#'        distributed independent component generating
#'        the row variable. A matrix
#'        defines a linear dag if the same permutation
#'        of its rows and columns can transform it into
#'        a lower diagonal matrix.
#' @return a list with class 'coefx' containing 
#'        the population coefficient for the first
#'        predictor variable in \code{fmla}, the residual 
#'        standard error of the regression, the conditional
#'        standard deviation of the residual of the first
#'        predictor and the ratio of the last two quantities
#'        which constitutes the 'standard error factor' which,
#'        if multiplied by 1/sqrt(n) is an estimate of the
#'        standard error of the estimate of the regression
#'        coefficient for the first predictor variable.
#' @examples
#' nams <- c('zc','zl','zr','c','x','y','m','i')
#' err <- rep(.2, length(nams))
#' names(err) <- nams
#' mat <- matrix(0, length(nams), length(nams))
#' rownames(mat) <- nams
#' colnames(mat) <- nams
#' 
#' # confounding back-door path
#' mat['zl','zc'] <- 2 
#' mat['zr','zc'] <- 2
#' mat['x','zl'] <- 1
#' mat['y','zr'] <- 2
#' 
#' # direct effect
#' mat['y','x'] <- 3
#' 
#' # indirect effect
#' mat['m','x'] <- 1
#' mat['y','m'] <- 1
#' 
#' # Instrumental variable 
#' mat['x','i'] <- 2
#' 
#' # 'Covariate'
#' mat['y','c'] <- 1
#' 
#' # independent error
#' diag(mat) <- 2
#' 
#' mat # not in lower diagonal form   
#' to_dag(mat) # can be permuted to lower-diagonal form
#' 
#' coefx(y ~ x, mat)  # with confounding
#' coefx(y ~ x + zc, mat)  # blocking back-door path
#' coefx(y ~ x + zr, mat) # blocking with lower SE
#' coefx(y ~ x + zl, mat) # blocking with worse SE
#' coefx(y ~ x + zr + c, mat)  # adding a 'covariate'
#' coefx(y ~ x + zr + m, mat)  # including a mediator
#' coefx(y ~ x + zl + i, mat)  # including an instrument
#' coefx(y ~ x + zl + i + c, mat) # I and C
#' 
#' # plotting added-variable plot ellipse 
#' lines(
#'     coefx(y ~ x + zr, mat),  
#'     lwd = 2, xv= 5,xlim = c(-5,10), ylim = c(-25, 50))
#' lines(
#'     coefx(y ~ x + zl, mat), new = F,
#'     col = 'red', xv = 5, lwd = 2)
#' lines(
#'     coefx(y ~ x + i, mat), new = F,
#'     col = 'dark green', xv = 5)
#' 
#' # comparing models
#' 
#' fmlas <- list(
#'   y ~ x, 
#'   y ~ x + zc, 
#'   y ~ x + zr, 
#'   y ~ x + zl,
#'   y ~ x + zr + c, 
#'   y ~ x + zr + m, 
#'   y ~ x + zl + i,
#'   y ~ x + zl + i + c
#' )
#' res <- lapply(fmlas, coefx, mat)
#' res <- lapply(res, function(ll) {
#'     ll$fmla <- paste(as.character(ll$fmla)[c(2,1,3)], collapse = ' ')
#'     ll$beta <- ll$beta[1]
#'     ll
#' })
#' 
#' df <- do.call(rbind.data.frame, res)
#' df 
#' @export
coefx <- function(fmla, dag){
	v <- covld(to_dag(dag))
	ynam <- as.character(fmla)[2]
	xnam <- labels(terms(fmla))
	v <- v[c(ynam,xnam),c(ynam,xnam)]
	beta <- solve(v[-1,-1], v[1,-1])
	sd_e <- sqrt(v[1,1] - sum(v[1,-1]*beta))
	sd_x_avp <- sqrt(1/solve(v[-1,-1])[1,1])
	ret <- list(beta=beta, sd_e =sd_e, sd_x_avp = sd_x_avp,
		 sd_betax_factor = sd_e/sd_x_avp, fmla = fmla)
	class(ret) <- 'coefx'
	ret
}
#' Plotting the added-variable plot for linear DAG
#' 
#' See \code{\link{coefx}} for an extended example.
#' 
#' @param cx an object of class 'coefx' produced by
#'        \code{\link{coefx}}.
#' @param new if FALSE add to previous plot. Default: TRUE.
#' @param xvertical position of vertical line to help visualize
#'        standard error factor. Default: 1.
#' @param col color of ellipse and lines. Default: 'black'.
#' @param lwd line width.
#' @param \dots other arguments passed to \code{\link{plot}}.
#' @export
lines.coefx <- function(cx, new = TRUE, xvertical = 1,  col = 'black', lwd = 2, ...) {
	fmla <- as.character(cx$fmla)
	xlab <- sub(' .*$','',fmla[3])
	ylab <- fmla[2]
	mlab <- paste(fmla[1], fmla[3])
	Tr <- with(cx, matrix(c(0, sd_e, sd_x_avp, sd_x_avp * beta[1]), nrow = 2))
	if(new) plot(ell(shape = Tr %*% t(Tr)), col = col, type = 'l', xlab = xlab, ylab = ylab, lwd = lwd, ...)
	else lines(ell(shape = Tr %*% t(Tr)), col = col, lwd = lwd) 
	abline(a=0,b=cx$beta[1], col = col, lwd = lwd)
	with(cx, abline(a=0,b=beta[1]- sd_e/sd_x_avp, col = col, lwd = lwd))
	with(cx, abline(a=0,b=beta[1]+ sd_e/sd_x_avp, col = col, lwd = lwd))
	abline(v = xvertical, lwd = lwd)
	with(cx, text(xvertical, xvertical *(beta[1]- sd_e/sd_x_avp), paste(' ',mlab) , adj = 0, cex = 1, col = col, ...))
}
#' @export
lines_ <-function(x, col = 'black', xvertical = 1, new = F, lwd = 2, ...) {
	lines(x, col = col, xvertical = xvertical , new = new, lwd = lwd, ... )
}
#' @export
ell <-
function (center = rep(0, 2), shape = diag(2), radius = 1, n = 100) 
{
    fac <- function(x) {
        xx <- svd(x, nu = 0)
        t(xx$v) * sqrt(pmax(xx$d, 0))
    }
    angles = (0:n) * 2 * pi/n
    if (length(radius) > 1) {
        ret <- lapply(radius, function(r) rbind(r * cbind(cos(angles), 
            sin(angles)), NA))
        circle <- do.call(rbind, ret)
    }
    else circle = radius * cbind(cos(angles), sin(angles))
    ret <- t(c(center) + t(circle %*% fac(shape)))
    attr(ret, "parms") <- list(center = rbind(center), 
        shape = shape, radius = radius)
    class(ret) <- "ell"
    ret
}